import { BrowserClient, defaultStackParser, getDefaultIntegrations, makeFetchTransport, Scope } from "@sentry/browser";

import { browserExtensionDSN } from "../config/dsn";

const integrations = getDefaultIntegrations({}).filter((defaultIntegration) => {
  return !["BrowserApiErrors", "Breadcrumbs", "GlobalHandlers"].includes(defaultIntegration.name);
});

const client = new BrowserClient({
  dsn: browserExtensionDSN,
  transport: makeFetchTransport,
  stackParser: defaultStackParser,
  integrations: integrations,
});

const scope = new Scope();
scope.setClient(client);

client.init(); // initializing has to be done after setting the client on the scope

export default client;

export const capture =
  <A extends unknown[], R>(fn: (...args: A) => R) =>
  (...args: A) => {
    try {
      return fn(...args);
    } catch (error) {
      client.captureException(error);
      throw error;
    }
  };

// Because we're a browser extension, we don't use Sentry's default global
// browser hooks - we don't want it to catch errors generated by the host page.
// However, we *do* want to catch unhandled promise exceptions that were caused
// by us. So we manually call the exception tracking method if the stack trace
// indicates the unhandled promise came from an exception. (We don't technically
// know which one, but we'll deal with that when it comes up)
export const promiseHandler = (event: PromiseRejectionEvent) => {
  if (event.reason instanceof Error && event.reason.stack?.includes(`chrome-extension://`)) {
    client.captureException(event.reason);
  }
};
