/**
 * Stream on the Clocktower extension content script.
 *
 * This code runs in the context of every matching URL in the "content_scripts"
 * section of the extension's manifest.json.
 *
 * It runs in an "isolated world" meaning that although it can access the page's
 * DOM, it doesn't have access to variables in the page's global context. It
 * also doesn't have access to any DOM properties that are set in that context.
 * This includes the Vue objects that we want to monitor as part of the
 * extension.
 *
 * However by injecting a <script> tag into the host DOM, *that* script has
 * access to the host variables, and can inspect the data we need.
 *
 * Even though they're run in different contexts, both scripts can create and
 * detect DOM events. That gives us a way to communicate between the two
 * contexts. Unfortunately because of the "isolated world" model, it's not
 * possible to pass any variables with DOM references this way - any protected
 * references you pass this way will become `null` when received at the other
 * end.
 *
 * To receive data from the injected script, we listen for these DOM CustomEvent
 * objects which contain sanitised data in the `detail` property.
 *
 * To pass that data on to the worker script, we use a Port obejct from the
 * Chrome extension API (`chrome.runtime`) which we can pass JSON objects to and
 * they will be distributed to any other port listeners.
 */

import { Game } from "./sotc/Game";
import { sotcEvent } from "./types/event";
import {
  Character,
  CharacterAlignment,
  CharacterType,
  Script,
} from "./types/sotc";
import { TaggedLogger } from "./util/TaggedLogger";

// Maps the default alignment for a character
const ALIGNMENTS = new Map<CharacterType, CharacterAlignment>([
  [CharacterType.TOWNSFOLK, CharacterAlignment.GOOD],
  [CharacterType.OUTSIDER, CharacterAlignment.GOOD],
  [CharacterType.MINION, CharacterAlignment.EVIL],
  [CharacterType.DEMON, CharacterAlignment.EVIL],
  [CharacterType.TRAVELER, CharacterAlignment.UNKNOWN],
]);

const TYPES = new Map([
  ["townsfolk", CharacterType.TOWNSFOLK],
  ["outsider", CharacterType.OUTSIDER],
  ["minion", CharacterType.MINION],
  ["demon", CharacterType.DEMON],
  ["traveler", CharacterType.TRAVELER],
]);

const logger = new TaggedLogger("Content");
logger.info("initialized");

const port = chrome.runtime.connect({ name: "gameTab" });

const output = document.createElement("div");
output.classList.add("sotc--debug-output");
document.documentElement.appendChild(output);

// Listen for a DOM CustomEvent of name `eventName` (generated by the injected
// script) and relay it to the extension worker script as a JSON message. The
// CustomEvent's `detail` property is passed as the `payload` value of the JSON
// message, passed through the `callback` function if present.
function relay<T>(
  eventName: keyof GlobalEventHandlersEventMap,
  callback: (a: T) => T = (e) => e
) {
  document.addEventListener(eventName, (e) => {
    if (e instanceof CustomEvent) {
      const data = callback(e.detail) || e.detail;
      logger.info("Relaying event", eventName, data, port);

      port.postMessage({
        type: eventName,
        payload: data,
      });
    }
  });
}

function injectScript() {
  const script = document.createElement("script");
  const runtimeUrl = chrome.runtime.getURL("inject.js");
  logger.debug("Injecting Vue monitor script", runtimeUrl);
  script.src = runtimeUrl;

  document.addEventListener("detectedScript", (e) => {
    if (e instanceof CustomEvent) {
      logger.info("Script detected", e.detail);

      const game = new Game(e.detail);

      port.postMessage({
        type: "gameState",
        payload: game,
      });
    }
  });

  document.addEventListener("sotc-script", (e) => {
    logger.info("Detected script change", e.detail);
    const { edition, roles } = e.detail;

    const mapRole: (r: botc.Role) => Character = (r) => {
      const { id, name, team, ability } = r;
      const type = TYPES.get(team);
      if (!type) throw new Error(`No type for team ${team}`);
      const alignment = ALIGNMENTS.get(type);
      if (!alignment) throw new Error(`No alignment for team ${team}`);
      return { id, name, ability, alignment, type };
    };

    const script: Script = {
      name: edition.name,
      author: edition.author,
      characters: roles.map(mapRole),
    };

    const game = new Game(script);

    port.postMessage({
      type: "gameState",
      payload: game,
    });
  });

  relay("sotc-gameState");
  relay("sotc-navigate");

  (document.head || document.documentElement).appendChild(script);
}

injectScript();
