/**
 * Stream on the Clocktower extension content script.
 *
 * This code runs in the context of every matching URL in the "content_scripts"
 * section of the extension's manifest.json.
 *
 * It runs in an "isolated world" meaning that although it can access the page's
 * DOM, it doesn't have access to variables in the page's global context. It
 * also doesn't have access to any DOM properties that are set in that context.
 * This includes the Vue objects that we want to monitor as part of the
 * extension.
 *
 * However by injecting a <script> tag into the host DOM, *that* script has
 * access to the host variables, and can inspect the data we need.
 *
 * Even though they're run in different contexts, both scripts can create and
 * detect DOM events. That gives us a way to communicate between the two
 * contexts. Unfortunately because of the "isolated world" model, it's not
 * possible to pass any variables with DOM references this way - any protected
 * references you pass this way will become `null` when received at the other
 * end.
 *
 * To receive data from the injected script, we listen for these DOM CustomEvent
 * objects which contain sanitised data in the `detail` property.
 *
 * To pass that data on to the worker script, we use a Port obejct from the
 * Chrome extension API (`chrome.runtime`) which we can pass JSON objects to and
 * they will be distributed to any other port listeners.
 */

// import { Game } from "./sotc/Game";
// import {
//   Character,
//   CharacterAlignment,
//   CharacterType,
//   Script,
// } from "./types/sotc";
import { SOTCEvent } from "./types/event";
import { TaggedLogger } from "./util/TaggedLogger";

// Maps the default alignment for a character
// const ALIGNMENTS = new Map<CharacterType, CharacterAlignment>([
//   [CharacterType.TOWNSFOLK, CharacterAlignment.GOOD],
//   [CharacterType.OUTSIDER, CharacterAlignment.GOOD],
//   [CharacterType.MINION, CharacterAlignment.EVIL],
//   [CharacterType.DEMON, CharacterAlignment.EVIL],
//   [CharacterType.TRAVELER, CharacterAlignment.UNKNOWN],
// ]);

// const TYPES = new Map([
//   ["townsfolk", CharacterType.TOWNSFOLK],
//   ["outsider", CharacterType.OUTSIDER],
//   ["minion", CharacterType.MINION],
//   ["demon", CharacterType.DEMON],
//   ["traveler", CharacterType.TRAVELER],
// ]);

const logger = new TaggedLogger("Content");
logger.info("initialized");

const port = chrome.runtime.connect({ name: "gameTab" });

// Listen for a DOM CustomEvent of name `eventName` (generated by the injected
// script) and relay it to the extension worker script as a JSON message. The
// CustomEvent's `detail` property is passed as the `payload` value of the JSON
// message, passed through the `callback` function if present.
export function relay<T extends keyof SOTCEvent>(eventName: T) {
  document.addEventListener(eventName, (e) => {
    if (e instanceof CustomEvent) {
      const detail = e.detail;
      logger.info("Relaying event", eventName, detail, port);

      port.postMessage({
        type: eventName,
        payload: detail,
      });
    }
  });
}

const output = document.createElement("div");
output.classList.add("sotc--debug-output");
document.documentElement.appendChild(output);

function injectScript() {
  const script = document.createElement("script");
  const runtimeUrl = chrome.runtime.getURL("inject.js");
  logger.debug("Injecting Vue monitor script", runtimeUrl);
  script.src = runtimeUrl;

  (document.head || document.documentElement).appendChild(script);
}

injectScript();
